---

import ScheduleCard from "../ScheduleCard.astro";
import { getLangFromUrl, useTranslations } from "../../../i18n/utils";
import { getSchedule } from "../../../data/api/sessionize_api";
import "./grid-style.css";


const schedule = (await getSchedule()).map((s) => {
  s.rooms = s.rooms.map((r) => {
    r.sessions = r.sessions.map((si) => {
      if (si.title.indexOf("42!") != -1){
        si.endsAt = "2024-10-26T14:35:00Z"
      }
      return si
    });
    return r
  });
  s.timeSlots = s.timeSlots.map((ts) => {
      ts.rooms = ts.rooms.map((r) => {
        if (r.session.title.indexOf("42!") != -1){
          r.session.endsAt = "2024-10-26T14:35:00Z"
        }
      return r
    });
    return ts
  })
  return s
});
const lang = getLangFromUrl(Astro.url);
const t = useTranslations(lang);

---
<div class="text-white">
  

{
    schedule.map((s) => {
      const totalScheduleCols = s.rooms.length;
      const totalScheduleRows = s.timeSlots.length;
      let skipPadding: {[key:string]:number} = s.rooms.map((room) => ({[room.id]:0})).reduce((a,b)=>({...a,...b}),{})
      return (
        <div class="mb-5">
          <p class="text-3xl font-bold mb-5">
            {new Date(s.date).toLocaleDateString("en-US", {
              day: "numeric",
              month: "long",
              weekday: "long",
            })}
          </p>
          {/* Some classes are created manually due to tilewind issues */}
          <div class={`grid grid-flow-row grid-cols-layout-${totalScheduleCols} grid-rows-layout-${totalScheduleRows} grid-cols-1 gap-4`} >
            {s.timeSlots.map((ts,ts_idx) => {

              const hasServiceSession = ts.rooms.some(
                (tsr) => tsr.session.isServiceSession,
              );
              
              const sessionsInTimeSlot = ts.rooms.map((tsr) => {
                const endDate = new Date(tsr.session.endsAt);
                endDate.setSeconds(0)
                endDate.setMilliseconds(0)
                const slots = !hasServiceSession? (
                  //Function that calculate the rows to take for this session
                  (()=>{
                    //Calculate the space to take (how many timeSlot takes this session (until a service session))
                    let session_len = 1
                    let last_is_service = false
                    for (let i = ts_idx+1; i < s.timeSlots.length; i++){
                      //No sessions
                      if (s.timeSlots[i].rooms.length == 0) continue
                      //Take time from one of the sessions
                      //Get next start date
                      const next_date = new Date(s.timeSlots[i].rooms[0].session.startsAt)
                      next_date.setSeconds(0)
                      next_date.setMilliseconds(0)
                      //If it's a service session, can't take this space
                      if (s.timeSlots[i].rooms.some( (tsr) => tsr.session.isServiceSession)){
                        last_is_service = true
                        continue //We need to check if replicate this session for the next timeSlot that is not a service session
                      }
                      if (last_is_service){ //We stopped at a service session and need to check if replicate this session in next timeSlots
                        if (next_date < endDate){
                          s.timeSlots[i].rooms.push(tsr) //Replicate
                        }
                        break
                      }
                      //Continue to get space until this session ends
                      if (next_date < endDate){
                        session_len ++
                      }else{
                        break
                      }
                    }
                    return session_len
                  })()
                ) : 1;
                if (slots > 1){
                  skipPadding[tsr.id.toString()] = slots-1
                }
                return {
                  data: tsr,
                  html: <div class={`xl:col-span-${ hasServiceSession ? totalScheduleCols : 1 } row-span-${slots}`}>
                    <ScheduleCard value={tsr} />
                  </div>
                };
              });
              
            const orderedSessions = (
                !hasServiceSession?
                s.rooms.map(
                    (room) => {
                        let session = sessionsInTimeSlot.find((target) => room.id == target.data.id)
                        if (!session){
                            if (skipPadding[room.id.toString()]){
                                skipPadding[room.id.toString()]--
                                return null
                            }
                            return <div />
                        }
                        return session?.html
                    }
                ).filter((ele)=>ele!=null) : sessionsInTimeSlot.map((session) => session.html)
            )
                
                return [
                <div class="font-medium text-2xl">
                    <p>{ts.slotStart.substring(0, 5)}</p>
                </div>,
                ...orderedSessions
                ];
            })}
          </div>
        </div>
      );
    })
  }
  {schedule.length == 0?<h3 class="underline">{t("scheduling.noschedule")}</h3>:null}
  
</div>